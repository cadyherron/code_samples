"""
Single-responsibility principle: a class/function should only have one job

Example: one function to calculate area, and one to provide the area in the right format
"""


"""
Open-closed principle: objects/entities should be open for extension but closed for modification

Example: don't reach into a class to keep adding more if/else blocks
"""


"""
Liskov substitution principle: every subclass/derived class should be substitutable for their base class

Example: Square should not derive from Rectangle 
"""


"""
Interface segregation principle: a client should never be forced to implement an interface that it doesn't use

Example: classes that don't need to provide empty method implementations
"""


"""
Dependency inversion principle: high-level modules should be easily reusable and unaffected by changes in low-level modules

Example: create abstraction between high-level and low-level, allows for easier re-use
"""
